---
import { type CollectionEntry, getCollection } from "astro:content";
import Pagination from "@/components/Paginator.astro";
import Note from "@/components/note/Note.astro";
import PageLayout from "@/layouts/Base.astro";
import { collectionDateSort } from "@/utils/date";
import type { GetStaticPaths, Page } from "astro";
import { Icon } from "astro-icon/components";

export const getStaticPaths = (async ({ paginate }) => {
    const MAX_NOTES_PER_PAGE = 10;
    const allNotes = await getCollection("note");
    const totalCount = allNotes.length;
    const totalPages = Math.ceil(totalCount / MAX_NOTES_PER_PAGE);
    return paginate(allNotes.sort(collectionDateSort), {
        pageSize: MAX_NOTES_PER_PAGE,
        props: { totalCount, totalPages },
    });
}) satisfies GetStaticPaths;

interface Props {
    page: Page<CollectionEntry<"note">>;
    uniqueTags: string[];
    totalCount: number;
    totalPages: number;
}

const { page, totalCount, totalPages } = Astro.props;
const currentPage = Number(Astro.params.page ?? 1);
const allNotes = await getCollection("note");
const uniqueNoteTags = [
	...new Set(allNotes.flatMap((n) => (n.data.tags ? [...n.data.tags] : []))),
].sort();

const meta = {
	description: "Read my collection of notes",
	title: "Notes",
};

const paginationProps = {
	...(page.url.prev && {
		prevUrl: {
			text: "← Previous Page",
			url: page.url.prev,
		},
	}),
	...(page.url.next && {
		nextUrl: {
			text: "Next Page →",
			url: page.url.next,
		},
	}),
};
---

<PageLayout meta={meta}>
    <div class="mb-12 relative flex items-center gap-3">
        <h2 class="title">Notes</h2>
        <a class="text-accent" href="/notes/rss.xml" target="_blank">
            <span class="sr-only">RSS feed</span>
            <Icon aria-hidden="true" class="h-6 w-6" focusable="false" name="mdi:rss" />
        </a>
        	<div class="text-xs text-gray-600 dark:text-gray-400 tracking-tight">
            		Page {currentPage}/{totalPages} · Total {totalCount}
        	</div>
    </div>
	<div class="grid sm:grid-cols-[3fr_1fr] sm:gap-x-8 sm:gap-y-16">
		<div>
			<ul id="notes-list" class="grid gap-6 sm:grid-cols-2 lg:grid-cols-2" role="list">
				{
					page.data.map((note) => (
						<li data-tags={(note.data.tags ?? []).join(",")}>
							<Note note={note} as="h2" isPreview />
						</li>
					))
				}
			</ul>
			<Pagination {...paginationProps} />
		</div>
		{
			!!uniqueNoteTags.length && (
				<aside class="not-prose">
					<h3 class="title mb-4 flex items-center gap-2 text-lg">
						<svg
							aria-hidden="true"
							class="h-6 w-6"
							fill="none"
							stroke="currentColor"
							stroke-linecap="round"
							stroke-linejoin="round"
							stroke-width="1.5"
							viewBox="0 0 24 24"
							xmlns="http://www.w3.org/2000/svg"
						>
							<path d="M0 0h24v24H0z" fill="none" stroke="none" />
							<path d="M7.859 6h-2.834a2.025 2.025 0 0 0 -2.025 2.025v2.834c0 .537 .213 1.052 .593 1.432l6.116 6.116a2.025 2.025 0 0 0 2.864 0l2.834 -2.834a2.025 2.025 0 0 0 0 -2.864l-6.117 -6.116a2.025 2.025 0 0 0 -1.431 -.593z" />
							<path d="M17.573 18.407l2.834 -2.834a2.025 2.025 0 0 0 0 -2.864l-7.117 -7.116" />
							<path d="M6 9h-.01" />
						</svg>
						Tags
					</h3>
					<ul id="notes-filter" class="space-y-2" role="list">
						{uniqueNoteTags.map((t) => (
							<li>
								<a
									class="cactus-link inline-block before:content-['#']"
									href={`?tag=${t}`}
									data-tag={t}
									aria-pressed="false"
								>
									{t}
								</a>
							</li>
						))}
					</ul>
					<div class="mt-4">
						<a class="hover:text-link" href="/notes/" data-tag="all">
							View all <span aria-hidden="true">→</span>
						</a>
					</div>
				</aside>
			)
		}
	</div>
</PageLayout>

<script>
	const filterEl = document.getElementById("notes-filter");
	const listEl = document.getElementById("notes-list");
	if (filterEl && listEl) {
		const url = new URL(window.location.href);
		let activeTag = url.searchParams.get("tag") || "all";

		function setActive(tag) {
			activeTag = tag;
			for (const link of filterEl.querySelectorAll("a[data-tag]")) {
				const isActive = link.getAttribute("data-tag") === tag;
				link.setAttribute("aria-pressed", String(isActive));
				link.classList.toggle("text-accent", isActive);
			}
		}

		function applyFilter(tag) {
			const items = listEl.querySelectorAll("li[data-tags]");
			items.forEach((li) => {
				const raw = li.getAttribute("data-tags") ?? "";
				const tags = raw
					.split(",")
					.map((t) => t.trim().toLowerCase())
					.filter(Boolean);
				const show = tag === "all" || tags.includes(tag.toLowerCase());
				li.classList.toggle("hidden", !show);
			});
		}

		filterEl.addEventListener("click", (e) => {
			const target = (e.target as HTMLElement).closest("a[data-tag]");
			if (!target) return;
			e.preventDefault();
			const tag = target.getAttribute("data-tag") ?? "all";
			const next = new URL(window.location.href);
			if (tag === "all") {
				next.searchParams.delete("tag");
			} else {
				next.searchParams.set("tag", tag);
			}
			window.history.replaceState({}, "", next);
			setActive(tag);
			applyFilter(tag);
		});

		// initialize
		setActive(activeTag);
		applyFilter(activeTag);
	}
</script>
